#ifndef _SRC_PROGRAMS_BLUSH_REFINEMENT_BLUSH_HELPERS_H
#define _SRC_PROGRAMS_BLUSH_REFINEMENT_BLUSH_HELPERS_H

#include <torch/torch.h>

/**
 * @brief Returns a torch tensor of a localized standard deviation.
 * 
 * @param grid Volume being passed to blush.
 * @param size Desired kernel size.
 * @return torch::Tensor containing the results of the 3D convolution operation.
 */
inline torch::Tensor get_local_std_dev(torch::Tensor grid, int size) {
    // Unsqueeze and clone the grid tensor
    torch::Tensor new_grid = grid.unsqueeze(1).clone( );
    torch::Tensor grid2    = new_grid.square( );

    // Create the kernel
    torch::Tensor ls     = torch::linspace(-1.5, 1.5, 2 * size + 1); // Create tensor of size 2 * size + 1 with evenly spaced values between -1.5 and 1.5 -- size passed as 10
    torch::Tensor kernel = torch::exp(-ls.square( )).to(new_grid.device( )); // Make normal dist (gets rid of negatives (square), applies exponential function(exp))
    kernel /= kernel.sum( );

    kernel = kernel.unsqueeze(0).unsqueeze(0).unsqueeze(3).unsqueeze(4); // Shape: (1, 1, kernel_size, 1, 1)

    // Set options, then perform 3D convolution
    torch::nn::functional::Conv3dFuncOptions options;

    // Pads tensors by size in either direction of x, y, and z dimensions (if size == 10, then padding totals 20)
    new_grid = torch::constant_pad_nd(new_grid, {size, size, size, size, size, size});
    grid2    = torch::constant_pad_nd(grid2, {size, size, size, size, size, size});

    // This convolution will remove the padded dimensions
    for ( int i = 0; i < 3; ++i ) {
        new_grid = new_grid.permute({0, 1, 4, 2, 3}); // Shift (N, C, D, W, H) then (N, C, H, D, W) and finally (N, C, W, H, D)
        new_grid = torch::nn::functional::conv3d(new_grid, kernel, options);

        grid2 = grid2.permute({0, 1, 4, 2, 3}); // Same permutation
        grid2 = torch::nn::functional::conv3d(grid2, /*weight=*/kernel, options);
    }

    torch::Tensor in_std = torch::sqrt(torch::clamp(grid2 - new_grid.square( ), 0));

    in_std = in_std.squeeze(0);

    return in_std.clone( );
}

/**
 * @brief Generate a 3D grid of weights where each dimension is of size block_size.
 * 
 * @param block_size The size of segments passed to the model -- comes from model's previously set model_block_size.
 * @param margin The thickness of the border around the distribution generated by 
 * @return Tensor 
 */
inline torch::Tensor make_weight_box(const int& block_size, int margin) {
    margin = (margin - 1 > 0) ? margin - 1 : 0;
    int s  = block_size - (margin * 2);

    // Create evenly spaced 1D tensors; should range from -27 to 27, with increments of...55?
    torch::Tensor x = torch::linspace(-s / 2, s / 2, s);
    torch::Tensor y = torch::linspace(-s / 2, s / 2, s);
    torch::Tensor z = torch::linspace(-s / 2, s / 2, s);

    // Broadcasting means these tensors can be subsequently expanded to fit the appropriate dimensions as needed
    // Each of these tensors is different, and later they are sliced together dimensionally
    // expand broadcasts the dimension with s, so the values of the linspace array are applied in all 3 dimensions
    // This is meant to replicate numpy.meshgrid functionality
    torch::Tensor xx = x.view({s, 1, 1}).expand({s, s, s});
    torch::Tensor yy = y.view({1, s, 1}).expand({s, s, s});
    torch::Tensor zz = z.view({1, 1, s}).expand({s, s, s});

    // Radial distance; performs pixelwise comparison of the values at each point in all 3 tensors, selecting the one with the largest value at each pixel
    // The max function actually returns both the raw values being compared along with the indices where the max value came from (including which tensor it came from)
    //  We want the actual values before applying cosine falloff
    xx                   = xx.abs( );
    yy                   = yy.abs( );
    zz                   = zz.abs( );
    torch::Tensor radius = torch::zeros_like(xx);

    for ( int k = 0; k < xx.size(2); k++ ) {
        for ( int j = 0; j < xx.size(1); j++ ) {
            for ( int i = 0; i < xx.size(0); i++ ) {
                float max = std::max(zz[i][j][k].item<float>( ), std::max(xx[i][j][k].item<float>( ), yy[i][j][k].item<float>( )));
                // max             = torch::max(max, zz[i][j][k].item<float>( ));
                radius[i][j][k] = max;
            }
        }
    }

    radius = torch::cos(radius / radius.max( ) * (M_PI / 2));

    // Sets up the output tensor that will slice from each of the tensors
    torch::Tensor weight_grid = torch::zeros({block_size, block_size, block_size});
    auto          slices      = weight_grid.slice(0, margin, block_size - margin).slice(1, margin, block_size - margin).slice(2, margin, block_size - margin);
    slices.copy_(radius);
    weight_grid = weight_grid.clamp_min(1e-6); // avoid zeros

    return weight_grid;
}

/**
 * @brief Generate what is essentially a cosine mask using torch functions for faster subsequent application
 * to a tensorized volume.
 * 
 * @param box_size Outer dimension of the mask (same as volume).
 * @param radius Size of outer edge of the mask in pixels.
 * @param mask_edge_width How wide in pixels the falloff edge of the mask should be.
 * @return torch::Tensor A 3D mask volume in tensor form.
 */
inline torch::Tensor generate_radial_mask(const int& box_size, const float& radius, const int& mask_edge_width) {
    float         bz2 = box_size / 2.0f;
    torch::Tensor ls  = torch::linspace(-bz2, bz2, box_size);
    torch::Tensor r   = torch::stack(torch::meshgrid({ls, ls, ls}), -1);

    r = torch::sqrt(torch::sum(torch::square(r), -1));

    torch::Tensor scale = torch::ones_like(r);

    if ( mask_edge_width > 0 ) {
        int edge_low  = radius - mask_edge_width / 2;
        int edge_high = radius + mask_edge_width / 2;

        // torch::where is a boolean mask function
        torch::Tensor mask = (r >= edge_low) & (r <= edge_high);
        scale              = torch::where(r > edge_high, 0, scale);
        // scale              = torch::where(mask, 0.5 + 0.5 * torch::cos(M_PI * (torch::where((r >= edge_low) & (r <= edge_high), r - edge_low, r)) / mask_edge_width), scale);
        scale = torch::where(mask, 0.5 + 0.5 * torch::cos(M_PI * (r - edge_low) / mask_edge_width), scale);
    }
    else {
        scale = torch::where(r > radius, 0, scale);
    }

    // write_real_values_to_text_file("cpp_radial_mask_writeout.txt", box_size, false, true, &scale);
    // compare_text_file_lines("cpp_radial_mask_writeout.txt", "py_radial_mask_writeout.txt", "comp_radial_mask_writeout.txt");

    return scale;
}
#endif